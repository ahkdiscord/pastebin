@top Program { 
  (Directive | statement)*
}

Directive {
  clipboardTimeoutDirective |
  dllLoadDirective |
  errorStdOutDirective |
  hotIfDirective |
  hotIfTimeoutDirective |
  hotstringDirective |
  includeDirective |
  includeAgainDirective |
  inputLevelDirective |
  maxThreadsDirective |
  maxThreadsBufferDirective |
  maxThreadsPerHotkeyDirective |
  noTrayIconDirective |
  requiresDirective |
  singleInstanceDirective |
  suspendExemptDirective |
  useHookDirective |
  warnDirective |
  winActivateForceDirective
}

@skip {} {
  clipboardTimeoutDirective { "#" clipboardTimeout space+ Integer }

  dllLoadDirective { "#" dllLoad space+ DirectiveString }

  errorStdOutDirective { "#" errorStdOut space+ DirectiveString }

  hotIfDirective { "#" hotIf space+ expression }

  hotIfTimeoutDirective { "#" hotIfTimeout space+ Integer }

  hotstringDirective {
    "#" hotstring space+ noMouse |
    "#" hotstring space+ endChars " " UnquotedDirectiveString |
    "#" hotstring space+ UnquotedDirectiveString
  }

  includeDirective {
    "#" include space+ DirectiveString |
    "#" include space+ "<" IncludeDirectiveLibName ">"
  }

  includeAgainDirective {
    "#" includeAgain space+ DirectiveString |
    "#" includeAgain space+ "<" IncludeDirectiveLibName ">"
  }

  inputLevelDirective {
    "#" inputLevel space+ Integer
  }

  maxThreadsDirective {
    "#" maxThreads space+ Integer
  }

  maxThreadsBufferDirective {
    "#" maxThreadsBuffer space+ DirectiveBoolean
  }

  maxThreadsPerHotkeyDirective {
    "#" maxThreadsPerHotkey space+ Integer
  }

  noTrayIconDirective {
    "#" noTrayIcon
  }

  requiresDirective {
    "#" requires space+ UnquotedDirectiveString
  }

  singleInstanceDirective {
    "#" singleInstance space+ (force | ignore | prompt | off)
  }

  suspendExemptDirective {
    "#" suspendExempt space+ DirectiveBoolean
  }

  useHookDirective {
    "#" useHook space+ DirectiveBoolean
  }

  warnDirective {
    "#" warn space+ (varUnset | localSameAsGlobal | unreachable | all) space* comma space* (msgBox | stdOut | outputDebug | off)
  }

  winActivateForceDirective {
    "#" winActivateForce
  }
}

statement {
  (
    callStatement |
    classDeclaration |
    functionDeclaration |
    controlFlowStatement |
    labelStatement |
    expression
  ) lineEnd
}

callStatement[@dynamicPrecedence=1] {
  FunctionName { identifier ~name } arguments
}

classDeclaration {
  Class ClassName (Extends ClassName)? "{" classBody "}"
}

ClassName {
  identifier ~name
}

classBody {
  (Static? (assignment | functionDeclaration | propertyDeclaration) lineEnd)*
}

functionDeclaration {
  FunctionName { identifier ~name } "(" parameters ")" "{" functionBody "}"
}

functionBody {
  statement*
}

variables {
  variable (comma variable)*
}

variable {
  VariableName { identifier ~name }
}

block {
  lineEnd statement | "{" statement* "}"
}

breakStatement {
  ControlFlowKeyword { break }
}
continueStatement {
  ControlFlowKeyword { continue }
}
forStatement {
  ControlFlowKeyword { for } (variables | "(" variables ")") ControlFlowKeyword { in } block
  untilStatement?
}
gotoStatement {
  ControlFlowKeyword { goto } (LabelName { identifier ~name } | parenthesis)
}
ifStatement {
  ControlFlowKeyword { if } expression block
}
loopStatement {
  (
    ControlFlowKeyword { loop } expression block |
    ControlFlowKeyword { loop files } expression (comma expression)? block |
    ControlFlowKeyword { loop parse } expression (comma expression)? (comma expression)? block |
    ControlFlowKeyword { loop read } expression (comma expression)? block
    ControlFlowKeyword { loop reg } expression (comma expression)? block
  )
  untilStatement?
}
returnStatement {
  ControlFlowKeyword { return } expression
}
switchStatement {
  ControlFlowKeyword { switch } expression "{" switchBody "}"
}
throwStatement {
  ControlFlowKeyword { throw } expression?
}
tryStatement {
  ControlFlowKeyword { try } (statement | "{" statement* "}")
  (ControlFlowKeyword { catch } (ClassName { identifier })? (as VariableName { identifier })? (statement | "{" statement* "}") )?
  (ControlFlowKeyword { else } (statement | "{" statement* "}"))?
  (ControlFlowKeyword { finally } (statement | "{" statement* "}"))?
}
whileStatement {
  ControlFlowKeyword { while } expression block
  untilStatement?
}
untilStatement {
  ControlFlowKeyword { until } expression
}

controlFlowStatement {
  breakStatement |
  continueStatement |
  forStatement |
  gotoStatement |
  ifStatement |
  loopStatement |
  returnStatement |
  switchStatement |
  throwStatement |
  whileStatement
}

switchBody {
  (
    ControlFlowKeyword { case } expression colon statement* (returnStatement | breakStatement) |
    ControlFlowKeyword { default } colon statement*
  )*
}

labelStatement {
  LabelName { identifier ~name } colon
}

propertyDeclaration {
  PropertyName { identifier ~name } "[" parameters "]"
  (FatArrow expression | "{" propertyBody "}")
}

propertyBody {
  (
    (Get | Set)
    (FatArrow expression | "{" functionBody "}")
  )*
}

parameters {
  () | (parameter (comma parameter)*)
}

parameter {
  !loosePrefix ByRef { ampersand? }
  ParameterName { identifier }
  !looseSuffix (
    question |
    (colonEqual expression)
  )?
}

arguments {
  () | argument (comma argument)*
}

argument {
  expression
}

expression {
  Operation |
  Integer |
  String |
  Boolean |
  VariableName { identifier ~name }
}

@external tokens controlFlowKeywords from "./ahk-v2.0.tokens" {
  as, break, case, catch, Class, continue, default, else, Extends, finally, files, for, goto, if, in, loop, parse, read, reg, return, switch, throw, try, until, while
}

@external tokens specialKeywords from "./ahk-v2.0.tokens" {
  Static,
  Get,
  Set,
  ContainmentOperator,
  Not,
  And,
  Or,
  IsSet,
  Boolean
}

@external tokens directiveKeywords from "./ahk-v2.0.tokens" {
  clipboardTimeout,
  dllLoad,
  errorStdOut,
  hotIf,
  hotIfTimeout,
  hotstring,
  include,
  includeAgain,
  inputLevel,
  maxThreads,
  maxThreadsBuffer,
  maxThreadsPerHotkey,
  noTrayIcon,
  requires,
  singleInstance,
  suspendExempt,
  useHook,
  warn,
  winActivateForce
  noMouse,
  endChars,
  force,
  ignore,
  prompt,
  off,
  varUnset,
  localSameAsGlobal,
  unreachable,
  all,
  msgBox,
  stdOut,
  outputDebug
}

DirectiveBoolean { Boolean | "0" | "1" }

@external specialize { identifier } specializeIdentifier from "./ahk-v2.0.tokens" {
  BuiltinVariable,
  BuiltinConstant,
  BuiltinFunction,
  BuiltinClass
}

objectKeyValuePair {
  (Name | percent expression percent)
  colon
  expression
}

@precedence {
  block,
  tightSuffix @left,
  looseSuffix @left,
  exponentiation @right,
  tightPrefix @right,
  multiplication @left,
  addition @left,
  shift @left,
  combination @left,
  concatenation @left,
  regexComparison @left,
  numericComparison @left,
  equalityComparison @left,
  containmentCheck @left,
  loosePrefix @right,
  andCombination @left,
  orCombination @left,
  maybeAlternation @left,
  ternaryFirst @left,
  ternarySecond @left,
  assignment @right,
  alternation @left
}

dereference { percent expression percent }
@skip {} { partialNameSubstitution { Name percent space* expression space* percent } }
@skip {} { access { Name dot Name | Name dot percent space* expression space* percent } }
parenthesis { "(" expression ~parenthesized ")" }
Operation {
  parenthesis |
  call { FunctionName { identifier ~name } !tightSuffix "(" arguments asterisk? ")" } |
  dynamicCall { parenthesis !tightSuffix "(" arguments asterisk? ")" } |
  itemAccess { expression !tightSuffix "[" expression "]" } |
  array { "[" (() | expression (comma expression)*) "]" } |
  object { "{" (() | objectKeyValuePair (comma objectKeyValuePair)*) "}" } |
  increment { plusPlus expression | expression !loosePrefix plusPlus } |
  decrement { minusMinus expression | expression !loosePrefix minusMinus } |
  power { expression !exponentiation asteriskAsterisk expression } |
  unaryMinus { !tightPrefix minus expression } |
  unaryPlus { !tightPrefix plus expression } |
  logicalNot { !tightPrefix exclamation expression } |
  bitwiseNot { !tightPrefix tilde expression } |
  multiply { expression !multiplication asterisk expression } |
  divide { expression !multiplication slash expression } |
  integerDivide { expression !multiplication slashSlash expression } |
  add { expression !addition plus expression } |
  subtract { expression !addition minus expression } |
  shiftLeft { expression !shift lessLess expression } |
  shiftRight { expression !shift greaterGreater expression } |
  logicalShiftRight { expression !shift greaterGreaterGreater expression } |
  bitwiseAnd { expression !combination ampersand expression } |
  bitwiseXor { expression !combination circumflex expression } |
  bitwiseOr { expression !combination pipe expression } |
  concatenate { expression !concatenation dot expression } |
  match { expression !regexComparison tildeEqual expression } |
  greaterThan { expression !numericComparison greater expression } |
  lessThan { expression !numericComparison less expression } |
  greaterThanOrEqualTo { expression !numericComparison greaterEqual expression } |
  lessThanOrEqualTo { expression !numericComparison lessEqual expression } |
  equalTo { expression !equalityComparison (equal | equalEqual) expression } |
  unequalTo { expression !equalityComparison (exclamationEqual | exclamationEqualEqual) expression } |
  containment { expression !containmentCheck ContainmentOperator expression } |
  logicalNotWord { !loosePrefix Not expression } |
  booleanAnd { expression !andCombination (ampersandAmpersand | And) expression } |
  booleanOr { expression !orCombination (pipePipe | Or) expression } |
  maybe { expression !maybeAlternation questionQuestion expression } |
  assignment |
  ternary { expression !ternaryFirst question expression !ternarySecond colon expression } |
  functionExpression { (FunctionName { identifier ~name })? "(" parameters ~parenthesized ")" FatArrow } |
  multi { expression !alternation comma expression }
}

assignment { expression !assignment (colonEqual | plusEqual | minusEqual | asteriskAsterisk | slashEqual | slashSlashEqual | dotEqual | pipeEqual | ampersandEqual | circumflexEqual | greaterGreaterEqual | lessLessEqual | greaterGreaterGreaterEqual) expression }

FatArrow { equalGreater expression }

Name { identifier }

@local tokens {
  doubleQuote { '"' }
  singleQuote { "'" }
  EscapeSequence { "`" _ }
  newLine { "\n" | @eof }
  @else stringContent
}

@skip {} {
  String {
    '"' (stringContent | EscapeSequence)* (newLine | doubleQuote) |
    "'" (stringContent | EscapeSequence)* (newLine | singleQuote)
  }
}

@local tokens {
  asteriskSlash { "*/" }
  @else blockCommentContent
}

@skip {} {
  BlockComment {
    "/*" blockCommentContent asteriskSlash
  }
}

@tokens {
  DirectiveString { UnquotedDirectiveString | QuotedDirectiveString }
  UnquotedDirectiveString { ![\n \t<>;]+ }
  QuotedDirectiveString { '"' ![\n"]* '"' }

  IncludeDirectiveLibName { ![<> \t\n\r;]+ }

  identifier { $[a-zA-Z_] $[a-z-A-Z_0-9]* }

  Integer { $[0-9]+ | "0x" $[0-9a-fA-F]* }

  LineComment { ";" ![\n]* }

  percent { "%" }
  dot { "." }
  question { "?" }
  plusPlus { "++" }
  minusMinus { "--" }
  asteriskAsterisk { "**" }
  minus { "-" }
  plus { "+" }
  exclamation { "!" }
  tilde { "~" }
  ampersand { "&" }
  asterisk { "*" }
  slash { "/" }
  slashSlash { "//" }
  lessLess { "<<" }
  greaterGreater { ">>" }
  greaterGreaterGreater { ">>>" }
  circumflex { "^" }
  pipe { "|" }
  tildeEqual { "~=" }
  greater { ">" }
  less { "<" }
  greaterEqual { ">=" }
  lessEqual { "<=" }
  equal { "=" }
  equalEqual { "==" }
  exclamationEqual { "!=" }
  exclamationEqualEqual { "!==" }
  ampersandAmpersand { "&&" }
  pipePipe { "||" }
  questionQuestion { "??" }
  colon { ":" }
  colonEqual { ":=" }
  plusEqual { "+=" }
  minusEqual { "-=" }
  asteriskEqual { "*=" }
  slashEqual { "/=" }
  slashSlashEqual { "//=" }
  dotEqual { ".=" }
  pipeEqual { "|=" }
  ampersandEqual { "&=" }
  circumflexEqual { "^=" }
  greaterGreaterEqual { ">>=" }
  lessLessEqual { "<<=" }
  greaterGreaterGreaterEqual { ">>>=" }
  equalGreater { "=>" }
  comma { "," }

  space { $[ \t] }

  lineEnd { "\n" | "\r\n" | @eof }
}

@skip { space+ | LineComment | BlockComment }

@detectDelim