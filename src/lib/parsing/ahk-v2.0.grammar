@top Program { 
  (Directive | statement | labelDeclaration | hotkeyDeclaration | hotstringDeclaration)*
}

Directive {
  (
    hash |
    clipboardTimeoutDirective |
    dllLoadDirective |
    errorStdOutDirective |
    hotIfDirective |
    hotIfTimeoutDirective |
    hotstringDirective |
    includeDirective |
    includeAgainDirective |
    inputLevelDirective |
    maxThreadsDirective |
    maxThreadsBufferDirective |
    maxThreadsPerHotkeyDirective |
    noTrayIconDirective |
    requiresDirective |
    singleInstanceDirective |
    suspendExemptDirective |
    useHookDirective |
    warnDirective |
    winActivateForceDirective
  ) lineEnd
}

clipboardTimeoutDirective { clipboardTimeout Integer }

dllLoadDirective { dllLoad DirectiveString }

errorStdOutDirective { errorStdOut DirectiveString }

hotIfDirective { hotIf expression }

hotIfTimeoutDirective { hotIfTimeout Integer }

hotstringDirective {
  hotstring noMouse |
  hotstring endChars UnquotedDirectiveString |
  hotstring UnquotedDirectiveString
}

includeDirective {
  include DirectiveString |
  include "<" IncludeDirectiveLibName ">"
}

includeAgainDirective {
  includeAgain DirectiveString |
  includeAgain "<" IncludeDirectiveLibName ">"
}

inputLevelDirective {
  inputLevel Integer
}

maxThreadsDirective {
  maxThreads Integer
}

maxThreadsBufferDirective {
  maxThreadsBuffer DirectiveBoolean
}

maxThreadsPerHotkeyDirective {
  maxThreadsPerHotkey Integer
}

noTrayIconDirective {
  noTrayIcon
}

requiresDirective {
  requires UnquotedDirectiveString+
}

singleInstanceDirective {
  singleInstance (force | ignore | prompt | off)
}

suspendExemptDirective {
  suspendExempt DirectiveBoolean
}

useHookDirective {
  useHook DirectiveBoolean
}

warnDirective {
  warn DirectiveKeyword { varUnset | localSameAsGlobal | unreachable | all } comma DirectiveKeyword { msgBox | stdOut | outputDebug | off }
}

winActivateForceDirective {
  winActivateForce
}

statement {
  (
    callStatement |
    classDeclaration |
    functionDeclaration |
    controlFlowStatement |
    expression
  ) lineEnd
}

callStatement[@dynamicPrecedence=1] {
  FunctionName { identifier ~name | BuiltinFunction ~name } arguments
}

classDeclaration {
  Class ClassName (Extends ClassName)? "{" classBody "}"
}

ClassName {
  identifier ~name
}

classBody {
  (Static? (assignment | functionDeclaration | propertyDeclaration) lineEnd)*
}

functionDeclaration {
  FunctionName { identifier ~name } "(" parameters ")" "{" functionBody "}"
}

functionBody {
  statement*
}

variables {
  variable (comma variable)*
}

variable {
  VariableName { identifier ~name }
}

block {
  lineEnd statement | "{" ~blockOrObject statement+ "}"
}

breakStatement {
  ControlFlowKeyword { break }
}
continueStatement {
  ControlFlowKeyword { continue }
}
forStatement {
  ControlFlowKeyword { for } (variables | "(" variables ")") ControlFlowKeyword { in } expression loopBlock
}
gotoStatement {
  ControlFlowKeyword { goto } (LabelName { identifier ~name } | parenthesis)
}
ifStatement {
  ControlFlowKeyword { if } expression block
  (ControlFlowKeyword { else if } expression block)*
  (ControlFlowKeyword { else } block)?
}
loopStatement {
  ControlFlowKeyword { loop } expression loopBlock |
  ControlFlowKeyword { loop files } expression (comma expression)? loopBlock |
  ControlFlowKeyword { loop parse } expression (comma expression)? (comma expression)? loopBlock |
  ControlFlowKeyword { loop read } expression (comma expression)? loopBlock |
  ControlFlowKeyword { loop reg } expression (comma expression)? loopBlock
}
returnStatement {
  ControlFlowKeyword { return } expression
}
switchStatement {
  ControlFlowKeyword { switch } expression "{" ~blockOrObject switchBody "}"
}
throwStatement {
  ControlFlowKeyword { throw } expression?
}
tryStatement {
  ControlFlowKeyword { try } (statement | "{" statement* "}")
  (ControlFlowKeyword { catch } (ClassName { identifier })? (as VariableName { identifier })? (statement | "{" statement* "}") )?
  (ControlFlowKeyword { else } (statement | "{" statement* "}"))?
  (ControlFlowKeyword { finally } (statement | "{" statement* "}"))?
}
whileStatement {
  ControlFlowKeyword { while } expression loopBlock
}
untilStatement {
  ControlFlowKeyword { until } expression
}

loopBlock {
  block untilStatement?
}

controlFlowStatement {
  breakStatement |
  continueStatement |
  forStatement |
  gotoStatement |
  ifStatement |
  loopStatement |
  returnStatement |
  switchStatement |
  throwStatement |
  whileStatement
}

switchBody {
  (
    ControlFlowKeyword { case } expression colon statement* (returnStatement | breakStatement) |
    ControlFlowKeyword { default } colon statement*
  )*
}

labelDeclaration {
  LabelName { identifier ~name } colon
}

hotkeyDeclaration {
  "°todo::"
}

hotstringDeclaration {
  "°::todo::"
}

propertyDeclaration {
  PropertyName { identifier ~name } "[" parameters "]"
  (FatArrow expression | "{" propertyBody "}")
}

propertyBody {
  (
    (Get | Set)
    (FatArrow expression | "{" functionBody "}")
  )*
}

parameters {
  () | (parameter (comma parameter)*)
}

parameter {
  !loosePrefix ByRef { ampersand? }
  ParameterName { identifier }
  !looseSuffix (
    question |
    (colonEqual (expression | Unset))
  )?
}

arguments {
  () | argument (comma argument)*
}

argument {
  expression
}

expression {
  Operation |
  Integer |
  Float |
  String |
  Boolean |
  VariableName { identifier ~name }
}

@external tokens controlFlowKeywords from "./ahk-v2.0.tokens" {
  as, break, case, catch, Class, continue, default, else, Extends, finally, files, for, goto, if, in, loop, parse, read, reg, return, switch, throw, try, until, while
}

@external tokens specialKeywords from "./ahk-v2.0.tokens" {
  Static,
  Get,
  Set,
  Boolean,
  IsSet,
  ContainmentOperator,
  Not,
  And,
  Or,
  Unset
}

@external tokens directiveKeywords from "./ahk-v2.0.tokens" {
  clipboardTimeout,
  dllLoad,
  errorStdOut,
  hotIf,
  hotIfTimeout,
  hotstring,
  include,
  includeAgain,
  inputLevel,
  maxThreads,
  maxThreadsBuffer,
  maxThreadsPerHotkey,
  noTrayIcon,
  requires,
  singleInstance,
  suspendExempt,
  useHook,
  warn,
  winActivateForce
  noMouse,
  endChars,
  force,
  ignore,
  prompt,
  off,
  varUnset,
  localSameAsGlobal,
  unreachable,
  all,
  msgBox,
  stdOut,
  outputDebug
}

DirectiveBoolean { Boolean | "0" | "1" }

@external specialize { identifier } specializeIdentifier from "./ahk-v2.0.tokens" {
  BuiltinVariable,
  BuiltinConstant,
  BuiltinFunction,
  BuiltinClass
}

objectKeyValuePair {
  (Name | percent expression percent)
  colon
  expression
}

@precedence {
  tightSuffix @left,
  looseSuffix @left,
  exponentiation @right,
  tightPrefix @right,
  multiplication @left,
  addition @left,
  shift @left,
  combination @left,
  concatenation @left,
  regexComparison @left,
  numericComparison @left,
  equalityComparison @left,
  containmentCheck @left,
  loosePrefix @right,
  andCombination @left,
  orCombination @left,
  maybeAlternation @left,
  ternaryFirst @left,
  ternarySecond @left,
  assignment @right,
  alternation @left
}

dereference { percent expression percent }
@skip {} { partialNameSubstitution { Name percent space* expression space* percent } }
@skip {} { access { Name dot Name | Name dot percent space* expression space* percent } }
parenthesis { "(" expression ~parenthesized ")" }
Operation {
  parenthesis |
  call { FunctionName { identifier ~name } !tightSuffix "(" arguments asterisk? ")" } |
  isSetCall { IsSet !tightSuffix "(" VariableName { identifier } ")" } |
  dynamicCall { parenthesis !tightSuffix "(" arguments asterisk? ")" } |
  itemAccess { expression !tightSuffix "[" expression "]" } |
  array { "[" (() | expression (comma expression)*) "]" } |
  object { "{" ~blockOrObject (() | objectKeyValuePair (comma objectKeyValuePair)*) "}" } |
  increment { plusPlus expression | expression !loosePrefix plusPlus } |
  decrement { minusMinus expression | expression !loosePrefix minusMinus } |
  power { expression !exponentiation asteriskAsterisk expression } |
  unaryMinus { !tightPrefix minus expression } |
  unaryPlus { !tightPrefix plus expression } |
  logicalNot { !tightPrefix exclamation expression } |
  bitwiseNot { !tightPrefix tilde expression } |
  multiply { expression !multiplication asterisk expression } |
  divide { expression !multiplication slash expression } |
  integerDivide { expression !multiplication slashSlash expression } |
  add { expression !addition plus expression } |
  subtract { expression !addition minus expression } |
  shiftLeft { expression !shift lessLess expression } |
  shiftRight { expression !shift greaterGreater expression } |
  logicalShiftRight { expression !shift greaterGreaterGreater expression } |
  bitwiseAnd { expression !combination ampersand expression } |
  bitwiseXor { expression !combination circumflex expression } |
  bitwiseOr { expression !combination pipe expression } |
  concatenate { expression !concatenation dot? expression } |
  match { expression !regexComparison tildeEqual expression } |
  greaterThan { expression !numericComparison greater expression } |
  lessThan { expression !numericComparison less expression } |
  greaterThanOrEqualTo { expression !numericComparison greaterEqual expression } |
  lessThanOrEqualTo { expression !numericComparison lessEqual expression } |
  equalTo { expression !equalityComparison (equal | equalEqual) expression } |
  unequalTo { expression !equalityComparison (exclamationEqual | exclamationEqualEqual) expression } |
  containment { expression !containmentCheck ContainmentOperator expression } |
  logicalNotWord { !loosePrefix Not expression } |
  booleanAnd { expression !andCombination (ampersandAmpersand | And) expression } |
  booleanOr { expression !orCombination (pipePipe | Or) expression } |
  maybe { expression !maybeAlternation questionQuestion expression } |
  assignment |
  ternary { expression !ternaryFirst question expression !ternarySecond colon expression } |
  functionExpression { (FunctionName { identifier ~name })? "(" parameters ~parenthesized ")" FatArrow } |
  multi { expression !alternation comma expression }
}

assignment { expression !assignment (colonEqual | plusEqual | minusEqual | asteriskAsterisk | slashEqual | slashSlashEqual | dotEqual | pipeEqual | ampersandEqual | circumflexEqual | greaterGreaterEqual | lessLessEqual | greaterGreaterGreaterEqual) expression }

FatArrow { equalGreater expression }

Name { identifier }

@local tokens {
  doubleQuote { '"' }
  doubleQuotedEscapeSequence { "`" _ }
  doubleQuotedNewLine { "\n" | @eof }
  @else doubleQuotedStringContent
}

@local tokens {
  singleQuote { "'" }
  singleQuotedEscapeSequence { "`" _ }
  singleQuotedNewLine { "\n" | @eof }
  @else singleQuotedStringContent
}

@skip {} {
  doubleQuotedString { '"' (EscapeSequence { doubleQuotedEscapeSequence } | doubleQuotedStringContent)* doubleQuote }
  singleQuotedString { "'" (EscapeSequence { singleQuotedEscapeSequence } | singleQuotedStringContent)* singleQuote }

  String { doubleQuotedString | singleQuotedString }
}

@local tokens {
  asteriskSlash { "*/" }
  @else blockCommentContent
}

@skip {} {
  BlockComment {
    "/*" blockCommentContent asteriskSlash
  }
}



@tokens {
  DirectiveString { UnquotedDirectiveString | QuotedDirectiveString }
  UnquotedDirectiveString { ![\n\r \t<>]+ }
  QuotedDirectiveString { '"' ![\n"]* '"' }

  IncludeDirectiveLibName { ![<> \t\n\r;]+ }

  @precedence { LineComment, "/*", DirectiveString, UnquotedDirectiveString, IncludeDirectiveLibName }

  identifier { $[a-zA-Z_] $[a-z-A-Z_0-9]* }

  Integer { simpleInteger | hexadecimalInteger }
  simpleInteger { $[0-9]+ }
  hexadecimalInteger { ("0x" | "0X") $[0-9a-fA-F]* }

  Float { simpleFloat | scientificFloat }
  simpleFloat { 
    $[0-9]+ "." $[0-9]* |
    $[0-9]* "." $[0-9]+
  }
  scientificFloat {
    ($[0-9]+ "." $[0-9]* | $[0-9]* "." $[0-9]+ | $[0-9]+) "e" ("+" | "-")? $[0-9]+
  }

  @precedence { Float, Integer, dot }

  LineComment { ";" ![\n]* }

  percent { "%" }
  dot { "." }
  question { "?" }
  plusPlus { "++" }
  minusMinus { "--" }
  asteriskAsterisk { "**" }
  minus { "-" }
  plus { "+" }
  exclamation { "!" }
  tilde { "~" }
  ampersand { "&" }
  asterisk { "*" }
  slash { "/" }
  slashSlash { "//" }
  lessLess { "<<" }
  greaterGreater { ">>" }
  greaterGreaterGreater { ">>>" }
  circumflex { "^" }
  pipe { "|" }
  tildeEqual { "~=" }
  greater { ">" }
  less { "<" }
  greaterEqual { ">=" }
  lessEqual { "<=" }
  equal { "=" }
  equalEqual { "==" }
  exclamationEqual { "!=" }
  exclamationEqualEqual { "!==" }
  ampersandAmpersand { "&&" }
  pipePipe { "||" }
  questionQuestion { "??" }
  colon { ":" }
  colonEqual { ":=" }
  plusEqual { "+=" }
  minusEqual { "-=" }
  asteriskEqual { "*=" }
  slashEqual { "/=" }
  slashSlashEqual { "//=" }
  dotEqual { ".=" }
  pipeEqual { "|=" }
  ampersandEqual { "&=" }
  circumflexEqual { "^=" }
  greaterGreaterEqual { ">>=" }
  lessLessEqual { "<<=" }
  greaterGreaterGreaterEqual { ">>>=" }
  equalGreater { "=>" }
  comma { "," }

  hash { "#" }

  space { $[ \t] }

  lineEnd { "\n" | "\r\n" | @eof }
}

@skip { space+ | LineComment | BlockComment }