@top Program { 
  (Directive | statement | labelDeclaration | hotkeyDeclaration | hotstringDeclaration)*
}

Directive {
  (
    "#" |
    clipboardTimeoutDirective |
    dllLoadDirective |
    errorStdOutDirective |
    hotIfDirective |
    hotIfTimeoutDirective |
    hotstringDirective |
    includeDirective |
    includeAgainDirective |
    inputLevelDirective |
    maxThreadsDirective |
    maxThreadsBufferDirective |
    maxThreadsPerHotkeyDirective |
    noTrayIconDirective |
    requiresDirective |
    singleInstanceDirective |
    suspendExemptDirective |
    useHookDirective |
    warnDirective |
    winActivateForceDirective
  ) lineEnd
}

clipboardTimeoutDirective { clipboardTimeout Integer }

dllLoadDirective { dllLoad DirectiveString? }

errorStdOutDirective { errorStdOut DirectiveString? }

hotIfDirective { hotIf expression? }

hotIfTimeoutDirective { hotIfTimeout Integer }

hotstringDirective {
  hotstring noMouse |
  hotstring endChars UnquotedDirectiveString |
  hotstring UnquotedDirectiveString
}

includeDirective {
  include DirectiveString |
  include "<" IncludeDirectiveLibName ">"
}

includeAgainDirective {
  includeAgain DirectiveString |
  includeAgain "<" IncludeDirectiveLibName ">"
}

inputLevelDirective {
  inputLevel Integer?
}

maxThreadsDirective {
  maxThreads Integer
}

maxThreadsBufferDirective {
  maxThreadsBuffer DirectiveBoolean?
}

maxThreadsPerHotkeyDirective {
  maxThreadsPerHotkey Integer
}

noTrayIconDirective {
  noTrayIcon
}

requiresDirective {
  requires UnquotedDirectiveString+
}

singleInstanceDirective {
  singleInstance (force | ignore | prompt | off)?
}

suspendExemptDirective {
  suspendExempt DirectiveBoolean?
}

useHookDirective {
  useHook DirectiveBoolean?
}

warnDirective {
  warn (DirectiveKeyword { varUnset | localSameAsGlobal | unreachable | all } ("," DirectiveKeyword { msgBox | stdOut | outputDebug | off })?)?
}

winActivateForceDirective {
  winActivateForce
}

statement[@name=statement] {
  (
    callStatement |
    classDeclaration |
    functionDeclaration |
    controlFlowStatement |
    expression
  ) lineEnd
}

callStatement[@dynamicPrecedence=1,@name=callStatement] {
  FunctionName { identifier ~name | BuiltinFunction ~name } arguments
}

classDeclaration[@name=classDeclaration] {
  Class ClassName (Extends ClassName)? "{" classBody "}"
}

ClassName {
  identifier ~name
}

classBody {
  (Static? (assignment | functionDeclaration | propertyDeclaration) lineEnd)*
}

functionDeclaration[@name=functionDeclaration] {
  FunctionName { identifier ~name } "(" parameters ")" "{" functionBody "}"
}

functionBody {
  statement*
}

variables {
  variable ("," variable)*
}

variable {
  VariableName { identifier ~name }
}

block[@dynamicPrecedence=1,@name=block] {
  lineEnd statement | lineEnd? !block "{" ~blockOrObject newLine+ statement+ "}"
}

breakStatement {
  ControlFlowKeyword { break }
}
continueStatement {
  ControlFlowKeyword { continue }
}
forStatement {
  ControlFlowKeyword { for } (variables | "(" variables ")") ControlFlowKeyword { in } expression loopBlock
}
gotoStatement {
  ControlFlowKeyword { goto } (LabelName { identifier ~name } | parenthesis)
}
ifStatement {
  ControlFlowKeyword { if } expression block
  (ControlFlowKeyword { else if } expression block)*
  (ControlFlowKeyword { else } block)?
}
loopStatement {
  ControlFlowKeyword { loop } expression loopBlock |
  ControlFlowKeyword { loop files } expression ("," expression)? loopBlock |
  ControlFlowKeyword { loop parse } expression ("," expression)? ("," expression)? loopBlock |
  ControlFlowKeyword { loop read } expression ("," expression)? loopBlock |
  ControlFlowKeyword { loop reg } expression ("," expression)? loopBlock
}
returnStatement {
  ControlFlowKeyword { return } expression
}
switchStatement {
  ControlFlowKeyword { switch } expression? "{" ~blockOrObject switchBody "}"
}
throwStatement {
  ControlFlowKeyword { throw } expression?
}
tryStatement {
  ControlFlowKeyword { try } block
  (ControlFlowKeyword { catch } (ClassName { identifier })? (ControlFlowKeyword { as } VariableName { identifier })? block )?
  (ControlFlowKeyword { else } block)?
  (ControlFlowKeyword { finally } block)?
}
whileStatement {
  ControlFlowKeyword { while } expression loopBlock
}
untilStatement {
  ControlFlowKeyword { until } expression
}

loopBlock {
  block untilStatement?
}

controlFlowStatement[@name=controlFlowStatement] {
  breakStatement |
  continueStatement |
  forStatement |
  gotoStatement |
  ifStatement |
  loopStatement |
  returnStatement |
  switchStatement |
  throwStatement |
  tryStatement |
  whileStatement
}

switchBody {
  (
    ControlFlowKeyword { case } expression ":" statement |
    ControlFlowKeyword { default } ":" statement*
  )*
}

labelDeclaration {
  LabelName { identifier ~name } ":"
}

hotkeyDeclaration {
  HotkeyModifiers { hotkeyModifier+ }? HotkeyName { identifier ~name } HotkeyModifiers { up }? "::"
}
@external tokens hotkeys from "./ahk-v2.0.tokens" {
  up
}

hotstringDeclaration {
  "Â°::todo::"
}

propertyDeclaration {
  PropertyName { identifier ~name } "[" parameters "]"
  (FatArrow expression | "{" propertyBody "}")
}

propertyBody {
  (
    (Get | Set)
    (FatArrow expression | "{" functionBody "}")
  )*
}

parameters {
  () | (parameter ("," parameter)*)
}

parameter[@name=parameter] {
  !loosePrefix ByRef { "&" }?
  ParameterName { identifier }
  !looseSuffix (
    "?" |
    (":=" (expression | Unset))
  )?
}

arguments {
  () | argument ("," argument)*
}

argument[@name=argument] {
  expression
}

expression[@name=expression] {
  Operation |
  Integer |
  Float |
  String |
  Boolean |
  VariableName { identifier ~name }
}

@external tokens controlFlowKeywords from "./ahk-v2.0.tokens" {
  as,
  break,
  case,
  catch,
  Class,
  continue,
  default,
  else,
  Extends,
  finally,
  files,
  for,
  goto,
  if,
  in,
  loop,
  parse,
  read,
  reg,
  return,
  switch,
  throw,
  try,
  until,
  while
}

@external tokens specialKeywords from "./ahk-v2.0.tokens" {
  Static,
  Get,
  Set,
  Boolean,
  IsSet,
  ContainmentOperator,
  Not,
  And,
  Or,
  Unset
}

@external tokens directiveKeywords from "./ahk-v2.0.tokens" {
  clipboardTimeout,
  dllLoad,
  errorStdOut,
  hotIf,
  hotIfTimeout,
  hotstring,
  include,
  includeAgain,
  inputLevel,
  maxThreads,
  maxThreadsBuffer,
  maxThreadsPerHotkey,
  noTrayIcon,
  requires,
  singleInstance,
  suspendExempt,
  useHook,
  warn,
  winActivateForce
  noMouse,
  endChars,
  force,
  ignore,
  prompt,
  off,
  varUnset,
  localSameAsGlobal,
  unreachable,
  all,
  msgBox,
  stdOut,
  outputDebug
}

DirectiveBoolean { Boolean | "0" | "1" }

@external specialize { identifier } specializeIdentifier from "./ahk-v2.0.tokens" {
  BuiltinVariable,
  BuiltinConstant,
  BuiltinFunction,
  BuiltinClass
}

objectKeyValuePair {
  (Name | "%" expression "%")
  ":"
  expression
}

@precedence {
  block @left,
  object @left,
  tightSuffix @left,
  looseSuffix @left,
  exponentiation @right,
  tightPrefix @right,
  multiplication @left,
  addition @left,
  shift @left,
  combination @left,
  concatenation @left,
  regexComparison @left,
  numericComparison @left,
  equalityComparison @left,
  containmentCheck @left,
  loosePrefix @right,
  andCombination @left,
  orCombination @left,
  maybeAlternation @left,
  ternaryFirst @left,
  ternarySecond @left,
  assignment @right,
  alternation @left
}

dereference { "%" expression "%" }
@skip {} { partialNameSubstitution { Name "%" space* expression space* "%" } }
@skip {} { access { Name "." Name | Name "." "%" space* expression space* "%" } }
parenthesis { "(" expression ~parenthesized ")" }
Operation {
  parenthesis |
  call { FunctionName { identifier ~name } !tightSuffix "(" arguments "*"? ")" } |
  isSetCall { IsSet !tightSuffix "(" VariableName { identifier } ")" } |
  dynamicCall { parenthesis !tightSuffix "(" arguments "*"? ")" } |
  itemAccess { expression !tightSuffix "[" expression "]" } |
  array { "[" (() | expression ("," expression)*) "]" } |
  object { !object "{" ~blockOrObject (() | objectKeyValuePair ("," objectKeyValuePair)*) "}" } |
  increment { "++" expression | expression !loosePrefix "++" } |
  decrement { "--" expression | expression !loosePrefix "--" } |
  power { expression !exponentiation "**" expression } |
  unaryMinus { !tightPrefix "-" expression } |
  unaryPlus { !tightPrefix "+" expression } |
  logicalNot { !tightPrefix "!" expression } |
  bitwiseNot { !tightPrefix "~" expression } |
  multiply { expression !multiplication "*" expression } |
  divide { expression !multiplication "/" expression } |
  integerDivide { expression !multiplication "//" expression } |
  add { expression !addition "+" expression } |
  subtract { expression !addition "-" expression } |
  shiftLeft { expression !shift "<<" expression } |
  shiftRight { expression !shift ">>" expression } |
  logicalShiftRight { expression !shift ">>>" expression } |
  bitwiseAnd { expression !combination "&" expression } |
  bitwiseXor { expression !combination "^" expression } |
  bitwiseOr { expression !combination "|" expression } |
  concatenate { expression !concatenation "."? expression } |
  match { expression !regexComparison "~=" expression } |
  greaterThan { expression !numericComparison ">" expression } |
  lessThan { expression !numericComparison "<" expression } |
  greaterThanOrEqualTo { expression !numericComparison ">=" expression } |
  lessThanOrEqualTo { expression !numericComparison "<=" expression } |
  equalTo { expression !equalityComparison ("=" | "==") expression } |
  unequalTo { expression !equalityComparison ("!=" | "!==") expression } |
  containment { expression !containmentCheck ContainmentOperator expression } |
  logicalNotWord { !loosePrefix Not expression } |
  booleanAnd { expression !andCombination ("&&" | And) expression } |
  booleanOr { expression !orCombination ("||" | Or) expression } |
  maybe { expression !maybeAlternation "??" expression } |
  assignment |
  ternary { expression !ternaryFirst "?" expression !ternarySecond ":" expression } |
  functionExpression { (FunctionName { identifier ~name })? "(" parameters ~parenthesized ")" FatArrow } |
  multi { expression !alternation "," expression }
}

assignment { expression !assignment (":=" | "+=" | "-=" | "*=" | "/=" | "//=" | ".=" | "|=" | "&=" | "^=" | ">>=" | "<<=" | ">>>=") expression }

FatArrow { "=>" expression }

Name { identifier }

@local tokens {
  doubleQuote { '"' }
  doubleQuotedEscapeSequence { "`" _ }
  doubleQuotedNewLine { "\n" | @eof }
  @else doubleQuotedStringContent
}

@local tokens {
  singleQuote { "'" }
  singleQuotedEscapeSequence { "`" _ }
  singleQuotedNewLine { "\n" | @eof }
  @else singleQuotedStringContent
}

@skip {} {
  doubleQuotedString { '"' (EscapeSequence { doubleQuotedEscapeSequence } | doubleQuotedStringContent)* doubleQuote }
  singleQuotedString { "'" (EscapeSequence { singleQuotedEscapeSequence } | singleQuotedStringContent)* singleQuote }

  String { doubleQuotedString | singleQuotedString }
}

@local tokens {
  asteriskSlash { "*/" }
  @else blockCommentContent
}

@skip {} {
  BlockComment {
    "/*" blockCommentContent asteriskSlash
  }
}

@tokens {
  DirectiveString { UnquotedDirectiveString | QuotedDirectiveString }
  UnquotedDirectiveString { ![\n\r \t<>]+ }
  QuotedDirectiveString { '"' ![\n"]* '"' }

  IncludeDirectiveLibName { ![<> \t\n\r;]+ }

  @precedence { LineComment, "/*", DirectiveString, UnquotedDirectiveString, IncludeDirectiveLibName }

  identifier { $[a-zA-Z_] $[a-z-A-Z_0-9]* }

  Integer { simpleInteger | hexadecimalInteger }
  simpleInteger { $[0-9]+ }
  hexadecimalInteger { ("0x" | "0X") $[0-9a-fA-F]* }

  Float { simpleFloat | scientificFloat }
  simpleFloat { 
    $[0-9]+ "." $[0-9]* |
    $[0-9]* "." $[0-9]+
  }
  scientificFloat {
    ($[0-9]+ "." $[0-9]* | $[0-9]* "." $[0-9]+ | $[0-9]+) "e" ("+" | "-")? $[0-9]+
  }

  hotkeyModifier { $[<>]? $[#!^+] | $[*~$] }
  @precedence { hotkeyModifier, "#", "+", "!", "~" }

  @precedence { Float, Integer, "." }

  LineComment { ";" ![\n]* }

  space { $[ \t] }

  newLine { "\n" | "\r\n" }

  lineEnd { newLine | @eof }
}

@skip { space+ | LineComment | BlockComment }