import { ExternalTokenizer, InputStream } from "@lezer/lr";
import * as terms from "./ahk-v2.0.gen.terms";

export function specializeIdentifier(name: string) {
  if (name.toLowerCase() === "true" || name.toLowerCase() === "false") return terms.Boolean;
  if (builtinVariables.has(name.toLowerCase())) return terms.BuiltinVariable;
  if (builtinConstants.has(name.toLowerCase())) return terms.BuiltinConstant;
  if (builtinFunctions.has(name.toLowerCase())) return terms.BuiltinFunction;
  if (builtinClasses.has(name.toLowerCase())) return terms.BuiltinClass;

  return -1;
}

// NOTE: This is a bit inefficient as it peeks a lot more than it would technically need to.
// The reason for this is code simplicity. The alternative would be a tree of switch-statements.
// This is better, unless it causes actual performance issues.
export const controlFlowKeywords = new ExternalTokenizer(input => {
  return (
    acceptIfMatch(input, "as", terms.as) ||
    acceptIfMatch(input, "break", terms._break) ||
    acceptIfMatch(input, "case", terms._case) ||
    acceptIfMatch(input, "catch", terms._catch) ||
    acceptIfMatch(input, "class", terms.Class) ||
    acceptIfMatch(input, "continue", terms._continue) ||
    acceptIfMatch(input, "default", terms._default) ||
    acceptIfMatch(input, "else", terms._else) ||
    acceptIfMatch(input, "extends", terms.Extends) ||
    acceptIfMatch(input, "finally", terms._finally) ||
    acceptIfMatch(input, "files", terms.files) ||
    acceptIfMatch(input, "for", terms._for) ||
    acceptIfMatch(input, "goto", terms.goto) ||
    acceptIfMatch(input, "if", terms._if) ||
    acceptIfMatch(input, "in", terms._in) ||
    acceptIfMatch(input, "loop", terms.loop) ||
    acceptIfMatch(input, "parse", terms.parse) ||
    acceptIfMatch(input, "read", terms.read) ||
    acceptIfMatch(input, "reg", terms.reg) ||
    acceptIfMatch(input, "return", terms._return) ||
    acceptIfMatch(input, "switch", terms._switch) ||
    acceptIfMatch(input, "throw", terms._throw) ||
    acceptIfMatch(input, "try", terms._try) ||
    acceptIfMatch(input, "until", terms.until) ||
    acceptIfMatch(input, "while", terms._while)
  );
});

export const directiveKeywords = new ExternalTokenizer(input => {
  return (
    acceptIfMatch(input, "clipboardtimeout", terms.clipboardTimeout) ||
    acceptIfMatch(input, "dllload", terms.dllLoad) ||
    acceptIfMatch(input, "errorstdout", terms.errorStdOut) ||
    acceptIfMatch(input, "hotif", terms.hotIf) ||
    acceptIfMatch(input, "hotiftimeout", terms.hotIfTimeout) ||
    acceptIfMatch(input, "hotstring", terms.hotstring) ||
    acceptIfMatch(input, "include", terms.include) ||
    acceptIfMatch(input, "includeagain", terms.includeAgain) ||
    acceptIfMatch(input, "inputlevel", terms.inputLevel) ||
    acceptIfMatch(input, "maxthreads", terms.maxThreads) ||
    acceptIfMatch(input, "maxthreadsbuffer", terms.maxThreadsBuffer) ||
    acceptIfMatch(input, "maxthreadsperhotkey", terms.maxThreadsPerHotkey) ||
    acceptIfMatch(input, "notrayicon", terms.noTrayIcon) ||
    acceptIfMatch(input, "requires", terms.requires) ||
    acceptIfMatch(input, "singleinstance", terms.singleInstance) ||
    acceptIfMatch(input, "suspendexempt", terms.suspendExempt) ||
    acceptIfMatch(input, "usehook", terms.useHook) ||
    acceptIfMatch(input, "warn", terms.warn) ||
    acceptIfMatch(input, "winactivateforce", terms.winActivateForce)
  );
});

export const specialKeywords = new ExternalTokenizer(input => {
  return (
    acceptIfMatch(input, "static", terms.Static) ||
    acceptIfMatch(input, "get", terms.Get) ||
    acceptIfMatch(input, "set", terms.Set) ||
    acceptIfMatch(input, "true", terms.Boolean) ||
    acceptIfMatch(input, "false", terms.Boolean) ||
    acceptIfMatch(input, "is", terms.ContainmentOperator) ||
    acceptIfMatch(input, "in", terms.ContainmentOperator) ||
    acceptIfMatch(input, "contains", terms.ContainmentOperator)
  );
});

function isNext(inputStream: InputStream, string: string): boolean {
  let input: string = "";

  for (let i = 0; i < string.length; i++) {
    input += String.fromCharCode(inputStream.peek(i));
  }

  return input.toLowerCase() === string.toLowerCase();
}

function acceptIfMatch(inputStream: InputStream, string: string, token: number): boolean {
  if (isNext(inputStream, string)) {
    inputStream.acceptToken(token, string.length);
    return true;
  }

  return false;
}

const builtinVariables = new Set([
  "a_workingdir",
  "a_scriptname",
  "a_listlines",
  "a_titlematchmode",
  "a_titlematchmodespeed",
  "a_detecthiddenwindows",
  "a_detecthiddentext",
  "a_fileencoding",
  "a_sendmode",
  "a_sendlevel",
  "a_storecapslockmode",
  "a_keydelay",
  "a_keyduration",
  "a_keydelayplay",
  "a_keydurationplay",
  "a_windelay",
  "a_controldelay",
  "a_menumaskkey",
  "a_mousedelay",
  "a_mousedelayplay",
  "a_defaultmousespeed",
  "a_coordmodetooltip",
  "a_coordmodepixel",
  "a_coordmodemouse",
  "a_coordmodecaret",
  "a_coordmodemenu",
  "a_regview",
  "a_allowmainwindow",
  "a_iconhidden",
  "a_icontip",
  "a_maxhotkeysperinterval",
  "a_hotkeyinterval",
  "a_hotkeymodifiertimeout",
  "a_clipboard",
  "a_index",
]);

const builtinConstants = new Set([
  "a_space",
  "a_tab",
  "a_args",
  "a_initialworkingdir",
  "a_scriptdir",
  "a_scriptfullpath",
  "a_scripthwnd",
  "a_linenumber",
  "a_linefile",
  "a_thisfunc",
  "a_ahkversion",
  "a_ahkpath",
  "a_iscompiled",
  "a_yyyy",
  "a_mm",
  "a_dd",
  "a_mmmm",
  "a_mmm",
  "a_dddd",
  "a_ddd",
  "a_wday",
  "a_yday",
  "a_yweek",
  "a_hour",
  "a_min",
  "a_sec",
  "a_msec",
  "a_now",
  "a_nowutc",
  "a_tickcount",
  "a_issuspended",
  "a_ispaused",
  "a_iscritical",
  "a_traymenu",
  "a_iconfile",
  "a_iconnumber",
  "a_timeidle",
  "a_timeidlephysical",
  "a_timeidlekeyboard",
  "a_timeidlemouse",
  "a_thishotkey",
  "a_priorhotkey",
  "a_priorkey",
  "a_timesincethishotkey",
  "a_timesincepriorhotkey",
  "a_endchar",
  "a_comspec",
  "a_temp",
  "a_osversion",
  "a_is64bitos",
  "a_ptrsize",
  "a_language",
  "a_computername",
  "a_username",
  "a_windir",
  "a_programfiles",
  "a_appdata",
  "a_appdatacommon",
  "a_desktop",
  "a_desktopcommon",
  "a_startmenu",
  "a_startmenucommon",
  "a_programs",
  "a_programscommon",
  "a_startup",
  "a_startupcommon",
  "a_mydocuments",
  "a_isadmin",
  "a_screenwidth",
  "a_screenheight",
  "a_screendpi",
  "a_cursor",
  "a_eventinfo",
  "a_lasterror",
  "a_loopfilename",
  "a_loopfileext",
  "a_loopfilepath",
  "a_loopfilefullpath",
  "a_loopfileshortpath",
  "a_loopfileshortname",
  "a_loopfiledir",
  "a_loopfiletimemodified",
  "a_loopfiletimecreated",
  "a_loopfiletimeaccessed",
  "a_loopfileattrib",
  "a_loopfilesize",
  "a_loopfilesizekb",
  "a_loopfilesizemb",
  "a_loopregname",
  "a_loopregtype",
  "a_loopregkey",
  "a_loopregtimemodified",
  "a_loopreadline",
  "a_loopfield",
  "true",
  "false",
]);

const builtinFunctions = new Set([
  "abs",
  "asin",
  "acos",
  "atan",
  "blockinput",
  "callbackcreate",
  "callbackfree",
  "caretgetpos",
  "ceil",
  "chr",
  "click",
  "clipwait",
  "comcall",
  "comobjactive",
  "comobjarray",
  "comobjconnect",
  "comobject",
  "comobjflags",
  "comobjfromptr",
  "comobjget",
  "comobjquery",
  "comobjtype",
  "comobjvalue",
  "comvalue",
  "controladditem",
  "controlchooseindex",
  "controlchoosestring",
  "controlclick",
  "controldeleteitem",
  "controlfinditem",
  "controlfocus",
  "controlgetchecked",
  "controlgetchoice",
  "controlgetclassnn",
  "controlgetenabled",
  "controlgetfocus",
  "controlgethwnd",
  "controlgetindex",
  "controlgetitems",
  "controlgetpos",
  "controlgetstyle",
  "controlgetexstyle",
  "controlgettext",
  "controlgetvisible",
  "controlhide",
  "controlhidedropdown",
  "controlmove",
  "controlsend",
  "controlsendtext",
  "controlsetchecked",
  "controlsetenabled",
  "controlsetstyle",
  "controlsetexstyle",
  "controlsettext",
  "controlshow",
  "controlshowdropdown",
  "coordmode",
  "cos",
  "critical",
  "dateadd",
  "datediff",
  "detecthiddentext",
  "detecthiddenwindows",
  "dircopy",
  "dircreate",
  "dirdelete",
  "direxist",
  "dirmove",
  "dirselect",
  "dllcall",
  "download",
  "driveeject",
  "drivegetcapacity",
  "drivegetfilesystem",
  "drivegetlabel",
  "drivegetlist",
  "drivegetserial",
  "drivegetspacefree",
  "drivegetstatus",
  "drivegetstatuscd",
  "drivegettype",
  "drivelock",
  "driveretract",
  "drivesetlabel",
  "driveunlock",
  "edit",
  "editgetcurrentcol",
  "editgetcurrentline",
  "editgetline",
  "editgetlinecount",
  "editgetselectedtext",
  "editpaste",
  "envget",
  "envset",
  "exit",
  "exitapp",
  "exp",
  "fileappend",
  "filecopy",
  "filecreateshortcut",
  "filedelete",
  "fileencoding",
  "fileexist",
  "fileinstall",
  "filegetattrib",
  "filegetshortcut",
  "filegetsize",
  "filegettime",
  "filegetversion",
  "filemove",
  "fileopen",
  "fileread",
  "filerecycle",
  "filerecycleempty",
  "fileselect",
  "filesetattrib",
  "filesettime",
  "float",
  "floor",
  "format",
  "formattime",
  "getkeyname",
  "getkeyvk",
  "getkeysc",
  "getkeystate",
  "getmethod",
  "groupactivate",
  "groupadd",
  "groupclose",
  "groupdeactivate",
  "guictrlfromhwnd",
  "guifromhwnd",
  "hasbase",
  "hasmethod",
  "hasprop",
  "hotif",
  "hotifwinactive",
  "hotifwinexist",
  "hotifwinnotactive",
  "hotifwinnotexist",
  "hotkey",
  "hotstring",
  "il_create",
  "il_add",
  "il_destroy",
  "imagesearch",
  "inidelete",
  "iniread",
  "iniwrite",
  "inputbox",
  "installkeybdhook",
  "installmousehook",
  "instr",
  "islabel",
  "isobject",
  "isset",
  "issetref",
  "keyhistory",
  "keywait",
  "listhotkeys",
  "listlines",
  "listvars",
  "listviewgetcontent",
  "loadpicture",
  "log",
  "ln",
  "max",
  "menufromhandle",
  "menuselect",
  "min",
  "mod",
  "monitorget",
  "monitorgetcount",
  "monitorgetname",
  "monitorgetprimary",
  "monitorgetworkarea",
  "mouseclick",
  "mouseclickdrag",
  "mousegetpos",
  "mousemove",
  "msgbox",
  "numget",
  "numput",
  "objaddref",
  "objrelease",
  "objbindmethod",
  "objfromptr",
  "objfromptraddref",
  "objgetbase",
  "objgetcapacity",
  "objhasownprop",
  "objownpropcount",
  "objownprops",
  "objptr",
  "objptraddref",
  "objsetbase",
  "objsetcapacity",
  "onclipboardchange",
  "onerror",
  "onexit",
  "onmessage",
  "ord",
  "outputdebug",
  "pause",
  "persistent",
  "pixelgetcolor",
  "pixelsearch",
  "postmessage",
  "processclose",
  "processexist",
  "processgetname",
  "processgetparent",
  "processgetpath",
  "processsetpriority",
  "processwait",
  "processwaitclose",
  "random",
  "regexmatch",
  "regexreplace",
  "regcreatekey",
  "regdelete",
  "regdeletekey",
  "regread",
  "regwrite",
  "reload",
  "round",
  "run",
  "runas",
  "runwait",
  "send",
  "sendtext",
  "sendinput",
  "sendplay",
  "sendevent",
  "sendlevel",
  "sendmessage",
  "sendmode",
  "setcapslockstate",
  "setcontroldelay",
  "setdefaultmousespeed",
  "setkeydelay",
  "setmousedelay",
  "setnumlockstate",
  "setscrolllockstate",
  "setregview",
  "setstorecapslockmode",
  "settimer",
  "settitlematchmode",
  "setwindelay",
  "setworkingdir",
  "shutdown",
  "sin",
  "sleep",
  "sort",
  "soundbeep",
  "soundgetinterface",
  "soundgetmute",
  "soundgetname",
  "soundgetvolume",
  "soundplay",
  "soundsetmute",
  "soundsetvolume",
  "splitpath",
  "sqrt",
  "statusbargettext",
  "statusbarwait",
  "strcompare",
  "strget",
  "strlen",
  "strlower",
  "strptr",
  "strput",
  "strreplace",
  "strsplit",
  "strtitle",
  "strupper",
  "substr",
  "suspend",
  "sysget",
  "sysgetipaddresses",
  "tan",
  "thread",
  "tooltip",
  "trayseticon",
  "traytip",
  "trim",
  "ltrim",
  "rtrim",
  "type",
  "varsetstrcapacity",
  "vercompare",
  "winactivate",
  "winactivatebottom",
  "winactive",
  "winclose",
  "winexist",
  "wingetclass",
  "wingetclientpos",
  "wingetcontrols",
  "wingetcontrolshwnd",
  "wingetcount",
  "wingetid",
  "wingetidlast",
  "wingetlist",
  "wingetminmax",
  "wingetpid",
  "wingetpos",
  "wingetprocessname",
  "wingetprocesspath",
  "wingetstyle",
  "wingetexstyle",
  "wingettext",
  "wingettitle",
  "wingettranscolor",
  "wingettransparent",
  "winhide",
  "winkill",
  "winmaximize",
  "winminimize",
  "winminimizeall",
  "winminimizeallundo",
  "winmove",
  "winmovebottom",
  "winmovetop",
  "winredraw",
  "winrestore",
  "winsetalwaysontop",
  "winsetenabled",
  "winsetregion",
  "winsetstyle",
  "winsetexstyle",
  "winsettitle",
  "winsettranscolor",
  "winsettransparent",
  "winshow",
  "winwait",
  "winwaitactive",
  "winwaitnotactive",
  "winwaitclose",
]);

const builtinClasses = new Set([
  "any",
  "object",
  "array",
  "buffer",
  "clipboardall",
  "class",
  "error",
  "memoryerror",
  "oserror",
  "targeterror",
  "timeouterror",
  "typeerror",
  "unseterror",
  "membererror",
  "propertyerror",
  "methoderror",
  "unsetitemerror",
  "valueerror",
  "indexerror",
  "zerodivisionerror",
  "file",
  "func",
  "boundfunc",
  "closure",
  "enumerator",
  "gui",
  // TODO: the following must be handled differently
  // "gui.control",
  // "gui.activex",
  // "gui.button",
  // "gui.checkbox",
  // "gui.custom",
  // "gui.datetime",
  // "gui.edit",
  // "gui.groupbox",
  // "gui.hotkey",
  // "gui.link",
  // "gui.list",
  // "gui.combobox",
  // "gui.ddl",
  // "gui.listbox",
  // "gui.tab",
  // "gui.listview",
  // "gui.monthcal",
  // "gui.pic",
  // "gui.progress",
  // "gui.radio",
  // "gui.slider",
  // "gui.statusbar",
  // "gui.text",
  // "gui.treeview",
  // "gui.updown",
  "inputhook",
  "map",
  "menu",
  "menubar",
  "regexmatchinfo",
  "primitive",
  "number",
  "float",
  "integer",
  "string",
  "varref",
  "comvalue",
  "comobjarray",
  "comobject",
  "comvalueref",
]);
